package io.mosn.coder.intellij.template.proto;

import io.mosn.coder.intellij.option.Configuration;
import io.mosn.coder.intellij.option.Metadata;
import io.mosn.coder.intellij.option.ProtocolOption;
import io.mosn.coder.intellij.option.Source;
import io.mosn.coder.intellij.util.CodeBuilder;

import java.util.ArrayList;
import java.util.List;

/**
 * @author yiji@apache.org
 */
public class BoltTemplate extends AbstractProtocolTemplate<ProtocolOption> {

    private static final String path = "pkg/protocol/bolt";

    @Override
    public Source api(ProtocolOption option) {
        String name = "api.go";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package bolt")
                .line()
                .append("import (")
                .append("\t\"mosn.io/api\"")
                .append(")")
                .line()
                .append("// NewRpcRequest is a utility function which build rpc Request object of bolt protocol.")
                .append("func NewRpcRequest(requestId uint32, headers api.HeaderMap, data api.IoBuffer) *Request {")
                .append("	request := &Request{")
                .append("		RequestHeader: RequestHeader{")
                .append("			Protocol:  ProtocolCode,")
                .append("			CmdType:   CmdTypeRequest,")
                .append("			CmdCode:   CmdCodeRpcRequest,")
                .append("			Version:   ProtocolVersion,")
                .append("			RequestId: requestId,")
                .append("			Codec:     Hessian2Serialize,")
                .append("			Timeout:   -1,")
                .append("		},")
                .append("	}")
                .line()
                .append("	// set headers")
                .append("	if headers != nil {")
                .append("		headers.Range(func(key, value string) bool {")
                .append("			request.Set(key, value)")
                .append("			return true")
                .append("		})")
                .append("	}")
                .line()
                .append("	// set content")
                .append("	if data != nil {")
                .append("		request.Content = data")
                .append("	}")
                .append("	return request")
                .append("}")
                .line()
                .append("// NewRpcResponse is a utility function which build rpc Response object of bolt protocol.")
                .append("func NewRpcResponse(requestId uint32, statusCode uint16, headers api.HeaderMap, data api.IoBuffer) *Response {")
                .append("	response := &Response{")
                .append("		ResponseHeader: ResponseHeader{")
                .append("			Protocol:       ProtocolCode,")
                .append("			CmdType:        CmdTypeResponse,")
                .append("			CmdCode:        CmdCodeRpcResponse,")
                .append("			Version:        ProtocolVersion,")
                .append("			RequestId:      requestId,")
                .append("			Codec:          Hessian2Serialize,")
                .append("			ResponseStatus: statusCode,")
                .append("		},")
                .append("	}")
                .line()
                .append("	// set headers")
                .append("	if headers != nil {")
                .append("		headers.Range(func(key, value string) bool {")
                .append("			response.Set(key, value)")
                .append("			return true")
                .append("		})")
                .append("	}")
                .line()
                .append("	// set content")
                .append("	if data != nil {")
                .append("		response.Content = data")
                .append("	}")
                .append("	return response")
                .append("}");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public Source command(ProtocolOption option) {
        String name = "command.go";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package bolt")
                .line()
                .append("import (")
                .append("\t\"mosn.io/api\"")
                .with("\t\"").with(option.context().getModule()).append("/pkg/common\"")
                .append(")")
                .line()
                .append("// RequestHeader is the header part of bolt v1 request")
                .append("type RequestHeader struct {")
                .append("	Protocol   byte // meta fields")
                .append("	CmdType    byte")
                .append("	CmdCode    uint16")
                .append("	Version    byte")
                .append("	RequestId  uint32")
                .append("	Codec      byte")
                .append("	Timeout    int32")
                .append("	ClassLen   uint16")
                .append("	HeaderLen  uint16")
                .append("	ContentLen uint32")
                .line()
                .append("	Class         string // payload fields")
                .append("	common.Header        // request key value pair")
                .append("}")
                .line()
                .append("// ~ HeaderMap")
                .append("func (h *RequestHeader) Clone() api.HeaderMap {")
                .append("	clone := &RequestHeader{}")
                .append("	*clone = *h")
                .line()
                .append("	// deep copy")
                .append("	clone.Header = *(h.Header.Clone().(*common.Header))")
                .line()
                .append("	return clone")
                .append("}")
                .line()
                .append("// Request is the cmd struct of bolt v1 request")
                .append("type Request struct {")
                .append("	RequestHeader")
                .line()
                .append("	rawData    []byte // raw data")
                .append("	rawMeta    []byte // sub slice of raw data, start from protocol code, ends to content length")
                .append("	rawClass   []byte // sub slice of raw data, class bytes")
                .append("	rawHeader  []byte // sub slice of raw data, header bytes")
                .append("	rawContent []byte // sub slice of raw data, content bytes")
                .line()
                .append("	Data    api.IoBuffer // wrapper of raw data")
                .append("	Content api.IoBuffer // wrapper of raw content")
                .line()
                .append("	ContentChanged bool // indicate that content changed")
                .append("}")
                .line()
                .append("var _ api.XFrame = &Request{}")
                .line()
                .append("// ~ XFrame")
                .append("func (r *Request) GetRequestId() uint64 {")
                .append("	return uint64(r.RequestHeader.RequestId)")
                .append("}")
                .line()
                .append("func (r *Request) SetRequestId(id uint64) {")
                .append("	r.RequestHeader.RequestId = uint32(id)")
                .append("}")
                .line()
                .append("func (r *Request) IsHeartbeatFrame() bool {")
                .append("	return r.RequestHeader.CmdCode == CmdCodeHeartbeat")
                .append("}")
                .line()
                .append("func (r *Request) GetTimeout() int32 {")
                .append("	return r.RequestHeader.Timeout")
                .append("}")
                .line()
                .append("func (r *Request) GetStreamType() api.StreamType {")
                .append("	switch r.RequestHeader.CmdType {")
                .append("	case CmdTypeRequest:")
                .append("		return api.Request")
                .append("	case CmdTypeRequestOneway:")
                .append("		return api.RequestOneWay")
                .append("	default:")
                .append("		return api.Request")
                .append("	}")
                .append("}")
                .line()
                .append("func (r *Request) GetHeader() api.HeaderMap {")
                .append("	return r")
                .append("}")
                .line()
                .append("func (r *Request) GetData() api.IoBuffer {")
                .append("	return r.Content")
                .append("}")
                .line()
                .append("func (r *Request) SetData(data api.IoBuffer) {")
                .append("	// judge if the address unchanged, assume that proxy logic will not operate the original Content buffer.")
                .append("	if r.Content != data {")
                .append("		r.ContentChanged = true")
                .append("		r.Content = data")
                .append("	}")
                .append("}")
                .line()
                .append("// RequestHeader is the header part of bolt v1 response")
                .append("type ResponseHeader struct {")
                .append("	Protocol       byte // meta fields")
                .append("	CmdType        byte")
                .append("	CmdCode        uint16")
                .append("	Version        byte")
                .append("	RequestId      uint32")
                .append("	Codec          byte")
                .append("	ResponseStatus uint16")
                .append("	ClassLen       uint16")
                .append("	HeaderLen      uint16")
                .append("	ContentLen     uint32")
                .line()
                .append("	Class         string // payload fields")
                .append("	common.Header        // request key value pair")
                .append("}")
                .line()
                .append("// ~ HeaderMap")
                .append("func (h *ResponseHeader) Clone() api.HeaderMap {")
                .append("	clone := &ResponseHeader{}")
                .append("	*clone = *h")
                .line()
                .append("	// deep copy")
                .append("	clone.Header = *(h.Header.Clone().(*common.Header))")
                .line()
                .append("	return clone")
                .append("}")
                .line()
                .append("// Response is the cmd struct of bolt v1 response")
                .append("type Response struct {")
                .append("	ResponseHeader")
                .line()
                .append("	rawData    []byte // raw data")
                .append("	rawMeta    []byte // sub slice of raw data, start from protocol code, ends to content length")
                .append("	rawClass   []byte // sub slice of raw data, class bytes")
                .append("	rawHeader  []byte // sub slice of raw data, header bytes")
                .append("	rawContent []byte // sub slice of raw data, content bytes")
                .line()
                .append("	Data    api.IoBuffer // wrapper of raw data")
                .append("	Content api.IoBuffer // wrapper of raw content")
                .line()
                .append("	ContentChanged bool // indicate that content changed")
                .append("}")
                .line()
                .append("var _ api.XRespFrame = &Response{}")
                .line()
                .append("// ~ XRespFrame")
                .append("func (r *Response) GetRequestId() uint64 {")
                .append("	return uint64(r.ResponseHeader.RequestId)")
                .append("}")
                .line()
                .append("func (r *Response) SetRequestId(id uint64) {")
                .append("	r.ResponseHeader.RequestId = uint32(id)")
                .append("}")
                .line()
                .append("func (r *Response) IsHeartbeatFrame() bool {")
                .append("	return r.ResponseHeader.CmdCode == CmdCodeHeartbeat")
                .append("}")
                .line()
                .append("// response contains no timeout")
                .append("func (r *Response) GetTimeout() int32 {")
                .append("	return -1")
                .append("}")
                .line()
                .append("func (r *Response) GetStreamType() api.StreamType {")
                .append("	return api.Response")
                .append("}")
                .line()
                .append("func (r *Response) GetHeader() api.HeaderMap {")
                .append("	return r")
                .append("}")
                .line()
                .append("func (r *Response) GetData() api.IoBuffer {")
                .append("	return r.Content")
                .append("}")
                .line()
                .append("func (r *Response) SetData(data api.IoBuffer) {")
                .append("	// judge if the address unchanged, assume that proxy logic will not operate the original Content buffer.")
                .append("	if r.Content != data {")
                .append("		r.ContentChanged = true")
                .append("		r.Content = data")
                .append("	}")
                .append("}")
                .line()
                .append("func (r *Response) GetStatusCode() uint32 {")
                .append("	return uint32(r.ResponseStatus)")
                .append("}");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public Source decoder(ProtocolOption option) {
        String name = "decoder.go";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package bolt")
                .line()
                .append("import (")
                .append("\t\"context\"")
                .append("\t\"encoding/binary\"")
                .append("\t\"mosn.io/api\"")
                .append("\t\"mosn.io/pkg/header\"")
                .line()
                .append("\t\"mosn.io/pkg/buffer\"")
                .append(")")
                .line()
                .append("func decodeRequest(ctx context.Context, data api.IoBuffer, oneway bool) (cmd interface{}, err error) {")
                .append("	bytesLen := data.Len()")
                .append("	bytes := data.Bytes()")
                .line()
                .append("	// 1. least bytes to decode header is RequestHeaderLen(22)")
                .append("	if bytesLen < RequestHeaderLen {")
                .append("		return")
                .append("	}")
                .line()
                .append("	// 2. least bytes to decode whole frame")
                .append("	classLen := binary.BigEndian.Uint16(bytes[14:16])")
                .append("	headerLen := binary.BigEndian.Uint16(bytes[16:18])")
                .append("	contentLen := binary.BigEndian.Uint32(bytes[18:22])")
                .line()
                .append("	frameLen := RequestHeaderLen + int(classLen) + int(headerLen) + int(contentLen)")
                .append("	if bytesLen < frameLen {")
                .append("		return")
                .append("	}")
                .append("	data.Drain(frameLen)")
                .line()
                .append("	// 3. decode header")
                .append("	request := &Request{}")
                .line()
                .append("	cmdType := CmdTypeRequest")
                .append("	if oneway {")
                .append("		cmdType = CmdTypeRequestOneway")
                .append("	}")
                .line()
                .append("	request.RequestHeader = RequestHeader{")
                .append("		Protocol:   ProtocolCode,")
                .append("		CmdType:    cmdType,")
                .append("		CmdCode:    binary.BigEndian.Uint16(bytes[2:4]),")
                .append("		Version:    bytes[4],")
                .append("		RequestId:  binary.BigEndian.Uint32(bytes[5:9]),")
                .append("		Codec:      bytes[9],")
                .append("		Timeout:    int32(binary.BigEndian.Uint32(bytes[10:14])),")
                .append("		ClassLen:   classLen,")
                .append("		HeaderLen:  headerLen,")
                .append("		ContentLen: contentLen,")
                .append("	}")
                .append("	request.Data = buffer.GetIoBuffer(frameLen)")
                .line()
                .append("	//4. copy data for io multiplexing")
                .append("	request.Data.Write(bytes[:frameLen])")
                .append("	request.rawData = request.Data.Bytes()")
                .line()
                .append("	//5. process wrappers: Class, Header, Content, Data")
                .append("	headerIndex := RequestHeaderLen + int(classLen)")
                .append("	contentIndex := headerIndex + int(headerLen)")
                .line()
                .append("	request.rawMeta = request.rawData[:RequestHeaderLen]")
                .append("	if classLen > 0 {")
                .append("		request.rawClass = request.rawData[RequestHeaderLen:headerIndex]")
                .append("		request.Class = string(request.rawClass)")
                .append("	}")
                .append("	if headerLen > 0 {")
                .append("		request.rawHeader = request.rawData[headerIndex:contentIndex]")
                .append("		err = header.DecodeHeader(request.rawHeader, &request.BytesHeader)")
                .append("	}")
                .append("	if contentLen > 0 {")
                .append("		request.rawContent = request.rawData[contentIndex:]")
                .append("		request.Content = buffer.NewIoBufferBytes(request.rawContent)")
                .append("	}")
                .append("	return request, err")
                .append("}")
                .line()
                .append("func decodeResponse(ctx context.Context, data api.IoBuffer) (cmd interface{}, err error) {")
                .append("	bytesLen := data.Len()")
                .append("	bytes := data.Bytes()")
                .line()
                .append("	// 1. least bytes to decode header is ResponseHeaderLen(20)")
                .append("	if bytesLen < ResponseHeaderLen {")
                .append("		return")
                .append("	}")
                .append("	// 2. least bytes to decode whole frame")
                .append("	classLen := binary.BigEndian.Uint16(bytes[12:14])")
                .append("	headerLen := binary.BigEndian.Uint16(bytes[14:16])")
                .append("	contentLen := binary.BigEndian.Uint32(bytes[16:20])")
                .line()
                .append("	frameLen := ResponseHeaderLen + int(classLen) + int(headerLen) + int(contentLen)")
                .append("	if bytesLen < frameLen {")
                .append("		return")
                .append("	}")
                .append("	data.Drain(frameLen)")
                .line()
                .append("	// 3. decode header")
                .append("	response := &Response{}")
                .line()
                .append("	response.ResponseHeader = ResponseHeader{")
                .append("		Protocol:       ProtocolCode,")
                .append("		CmdType:        CmdTypeResponse,")
                .append("		CmdCode:        binary.BigEndian.Uint16(bytes[2:4]),")
                .append("		Version:        bytes[4],")
                .append("		RequestId:      binary.BigEndian.Uint32(bytes[5:9]),")
                .append("		Codec:          bytes[9],")
                .append("		ResponseStatus: binary.BigEndian.Uint16(bytes[10:12]),")
                .append("		ClassLen:       classLen,")
                .append("		HeaderLen:      headerLen,")
                .append("		ContentLen:     contentLen,")
                .append("	}")
                .append("	response.Data = buffer.GetIoBuffer(frameLen)")
                .line()
                .append("	//TODO: test recycle by model, so we can recycle request/response models, headers also")
                .append("	//4. copy data for io multiplexing")
                .append("	response.Data.Write(bytes[:frameLen])")
                .append("	response.rawData = response.Data.Bytes()")
                .line()
                .append("	//5. process wrappers: Class, Header, Content, Data")
                .append("	headerIndex := ResponseHeaderLen + int(classLen)")
                .append("	contentIndex := headerIndex + int(headerLen)")
                .line()
                .append("	response.rawMeta = response.rawData[:ResponseHeaderLen]")
                .append("	if classLen > 0 {")
                .append("		response.rawClass = response.rawData[ResponseHeaderLen:headerIndex]")
                .append("		response.Class = string(response.rawClass)")
                .append("	}")
                .append("	if headerLen > 0 {")
                .append("		response.rawHeader = response.rawData[headerIndex:contentIndex]")
                .append("		err = header.DecodeHeader(response.rawHeader, &response.BytesHeader)")
                .append("	}")
                .append("	if contentLen > 0 {")
                .append("		response.rawContent = response.rawData[contentIndex:]")
                .append("		response.Content = buffer.NewIoBufferBytes(response.rawContent)")
                .append("	}")
                .append("	return response, err")
                .append("}");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public Source encoder(ProtocolOption option) {
        String name = "encoder.go";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package bolt")
                .line()
                .append("import (")
                .append("\t\"context\"")
                .append("\t\"encoding/binary\"")
                .append("\t\"mosn.io/api\"")
                .append("\t\"mosn.io/pkg/header\"")
                .line()
                .append("\t\"mosn.io/pkg/buffer\"")
                .append(")")
                .line()
                .append("func encodeRequest(ctx context.Context, request *Request) (api.IoBuffer, error) {")
                .append("	// 1. fast-path, use existed raw data")
                .append("	if request.rawData != nil {")
                .append("		// 1.1 replace requestId")
                .append("		binary.BigEndian.PutUint32(request.rawMeta[RequestIdIndex:], request.RequestId)")
                .line()
                .append("		// 1.2 check if header/content changed")
                .append("		if !request.Header.Changed && !request.ContentChanged {")
                .append("			// hack: increase the buffer count to avoid premature recycle")
                .append("			request.Data.Count(1)")
                .append("			return request.Data, nil")
                .append("		}")
                .append("	}")
                .line()
                .append("	// 2. slow-path, construct buffer from scratch")
                .line()
                .append("	// 2.1 calculate frame length")
                .append("	if request.Class != \"\" {")
                .append("		request.ClassLen = uint16(len(request.Class))")
                .append("	}")
                .append("	if len(request.Header.Kvs) != 0 {")
                .append("		request.HeaderLen = uint16(header.GetHeaderEncodeLength(&request.BytesHeader))")
                .append("	}")
                .append("	if request.Content != nil {")
                .append("		request.ContentLen = uint32(request.Content.Len())")
                .append("	}")
                .append("	frameLen := RequestHeaderLen + int(request.ClassLen) + int(request.HeaderLen) + int(request.ContentLen)")
                .line()
                .append("	// 2.2 alloc encode buffer, this buffer will be recycled after connection.Write")
                .append("	buf := buffer.GetIoBuffer(frameLen)")
                .line()
                .append("	// 2.3 encode: meta, class, header, content")
                .append("	// 2.3.1 meta")
                .append("	buf.WriteByte(request.Protocol)")
                .append("	buf.WriteByte(request.CmdType)")
                .append("	buf.WriteUint16(request.CmdCode)")
                .append("	buf.WriteByte(request.Version)")
                .append("	buf.WriteUint32(request.RequestId)")
                .append("	buf.WriteByte(request.Codec)")
                .append("	buf.WriteUint32(uint32(request.Timeout))")
                .append("	buf.WriteUint16(request.ClassLen)")
                .append("	buf.WriteUint16(request.HeaderLen)")
                .append("	buf.WriteUint32(request.ContentLen)")
                .append("	// 2.3.2 class")
                .append("	if request.ClassLen > 0 {")
                .append("		buf.WriteString(request.Class)")
                .append("	}")
                .append("	// 2.3.3 header")
                .append("	if request.HeaderLen > 0 {")
                .append("		header.EncodeHeader(buf, &request.BytesHeader)")
                .append("	}")
                .append("	// 2.3.4 content")
                .append("	if request.ContentLen > 0 {")
                .append("		// use request.Content.WriteTo might have error under retry scene")
                .append("		buf.Write(request.Content.Bytes())")
                .append("	}")
                .line()
                .append("	return buf, nil")
                .append("}")
                .line()
                .append("func encodeResponse(ctx context.Context, response *Response) (api.IoBuffer, error) {")
                .append("	// 1. fast-path, use existed raw data")
                .append("	if response.rawData != nil {")
                .append("		// 1. replace requestId")
                .append("		binary.BigEndian.PutUint32(response.rawMeta[RequestIdIndex:], uint32(response.RequestId))")
                .line()
                .append("		// 2. check header change")
                .append("		if !response.Header.Changed && !response.ContentChanged {")
                .append("			// hack: increase the buffer count to avoid premature recycle")
                .append("			response.Data.Count(1)")
                .append("			return response.Data, nil")
                .append("		}")
                .append("	}")
                .line()
                .append("	// 2. slow-path, construct buffer from scratch")
                .line()
                .append("	// 2.1 calculate frame length")
                .append("	if response.Class != \"\" {")
                .append("		response.ClassLen = uint16(len(response.Class))")
                .append("	}")
                .append("	if len(response.Header.Kvs) != 0 {")
                .append("		response.HeaderLen = uint16(header.GetHeaderEncodeLength(&response.BytesHeader))")
                .append("	}")
                .append("	if response.Content != nil {")
                .append("		response.ContentLen = uint32(response.Content.Len())")
                .append("	}")
                .append("	frameLen := ResponseHeaderLen + int(response.ClassLen) + int(response.HeaderLen) + int(response.ContentLen)")
                .line()
                .append("	// 2.2 alloc encode buffer, this buffer will be recycled after connection.Write")
                .append("	buf := buffer.GetIoBuffer(frameLen)")
                .line()
                .append("	// 2.3 encode: meta, class, header, content")
                .append("	// 2.3.1 meta")
                .append("	buf.WriteByte(response.Protocol)")
                .append("	buf.WriteByte(response.CmdType)")
                .append("	buf.WriteUint16(response.CmdCode)")
                .append("	buf.WriteByte(response.Version)")
                .append("	buf.WriteUint32(response.RequestId)")
                .append("	buf.WriteByte(response.Codec)")
                .append("	buf.WriteUint16(response.ResponseStatus)")
                .append("	buf.WriteUint16(response.ClassLen)")
                .append("	buf.WriteUint16(response.HeaderLen)")
                .append("	buf.WriteUint32(response.ContentLen)")
                .append("	// 2.3.2 class")
                .append("	if response.ClassLen > 0 {")
                .append("		buf.WriteString(response.Class)")
                .append("	}")
                .append("	// 2.3.3 header")
                .append("	if response.HeaderLen > 0 {")
                .append("		header.EncodeHeader(buf, &response.BytesHeader)")
                .append("	}")
                .append("	// 2.3.4 content")
                .append("	if response.ContentLen > 0 {")
                .append("		// use request.Content.WriteTo might have error under retry scene")
                .append("		buf.Write(response.Content.Bytes())")
                .append("	}")
                .line()
                .append("	return buf, nil")
                .append("}");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public Source mapping(ProtocolOption option) {
        String name = "mapping.go";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package bolt")
                .line()
                .append("import (")
                .append("\t\"context\"")
                .append("\t\"errors\"")
                .line()
                .append("\t\"net/http\"")
                .line()
                .append("\t\"mosn.io/api\"")
                .append(")")
                .line()
                .append("type StatusMapping struct{}")
                .line()
                .append("func (m StatusMapping) MappingHeaderStatusCode(ctx context.Context, headers api.HeaderMap) (int, error) {")
                .append("	cmd, ok := headers.(api.XRespFrame)")
                .append("	if !ok {")
                .append("\t\treturn 0, errors.New(\"no response status in headers\")")
                .append("	}")
                .append("	code := uint16(cmd.GetStatusCode())")
                .append("	switch code {")
                .append("	case ResponseStatusSuccess:")
                .append("		return http.StatusOK, nil")
                .append("	case ResponseStatusServerThreadpoolBusy:")
                .append("		return http.StatusServiceUnavailable, nil")
                .append("	case ResponseStatusTimeout:")
                .append("		return http.StatusGatewayTimeout, nil")
                .append("		//case RESPONSE_STATUS_CLIENT_SEND_ERROR: // CLIENT_SEND_ERROR maybe triggered by network problem, 404 is not match")
                .append("		//	return http.StatusNotFound, nil")
                .append("	case ResponseStatusConnectionClosed:")
                .append("		return http.StatusBadGateway, nil")
                .append("	default:")
                .append("		return http.StatusInternalServerError, nil")
                .append("	}")
                .append("}");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public Source matcher(ProtocolOption option) {
        String name = "matcher.go";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package bolt")
                .line()
                .append("import (")
                .append("\t\"mosn.io/api\"")
                .append(")")
                .line()
                .append("// predicate first byte '0x1'")
                .append("func Matcher(data []byte) api.MatchResult {")
                .append("	length := len(data)")
                .append("	if length == 0 {")
                .append("		return api.MatchAgain")
                .append("	}")
                .line()
                .append("	if data[0] == ProtocolCode {")
                .append("		return api.MatchSuccess")
                .append("	}")
                .line()
                .append("	return api.MatchFailed")
                .append("}");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public Source protocol(ProtocolOption option) {
        String name = "protocol.go";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package bolt")
                .line()
                .append("import (")
                .append("\t\"context\"")
                .append("\t\"fmt\"")
                .append("\t\"net/http\"")
                .append("\t\"sync/atomic\"")
                .line()
                .append("\t\"mosn.io/api\"")
                .line()
                .append("\t\"mosn.io/pkg/log\"")
                .append(")")
                .line()
                .append("/**")
                .append(" * Request command protocol for v1")
                .append(" * 0     1     2           4           6           8          10           12          14         16")
                .append(" * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+")
                .append(" * |proto| type| cmd code  |ver2 |   requestID           |codec|        timeout        |  classLen |")
                .append(" * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+")
                .append(" * |headerLen  | contentLen            |                             ... ...                       |")
                .append(" * +-----------+-----------+-----------+                                                            ")
                .append(" * |               className + header  + content  bytes                                            |")
                .append(" * +                                                                                               +")
                .append(" * |                               ... ...                                                         |")
                .append(" * +-----------------------------------------------------------------------------------------------+")
                .append(" *")
                .append(" * proto: code for protocol")
                .append(" * type: request/response/request oneway")
                .append(" * cmd code: code for remoting command")
                .append(" * ver2:version for remoting command")
                .append(" * requestID: id of request")
                .append(" * codec: code for codec")
                .append(" * headerLen: length of header")
                .append(" * contentLen: length of content")
                .append(" *")
                .append(" * Response command protocol for v1")
                .append(" * 0     1     2     3     4           6           8          10           12          14         16")
                .append(" * +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+")
                .append(" * |proto| type| cmd code  |ver2 |   requestID           |codec|resp status|  classLen |headerLen  |")
                .append(" * +-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+")
                .append(" * | contentLen            |                  ... ...                                              |")
                .append(" * +-----------------------+                                                                       +")
                .append(" * |                         className + header  + content  bytes                                  |")
                .append(" * +                                                                                               +")
                .append(" * |                               ... ...                                                         |")
                .append(" * +-----------------------------------------------------------------------------------------------+")
                .append(" * resp status: response status")
                .append(" */")
                .line()
                .append("type BoltProtocol struct{}")
                .line()
                .append("// types.Protocol")
                .append("func (proto BoltProtocol) Name() api.ProtocolName {")
                .append("	return ProtocolName")
                .append("}")
                .line()
                .append("func (proto BoltProtocol) Encode(ctx context.Context, model interface{}) (api.IoBuffer, error) {")
                .append("	switch frame := model.(type) {")
                .append("	case *Request:")
                .append("		return encodeRequest(ctx, frame)")
                .append("	case *Response:")
                .append("		return encodeResponse(ctx, frame)")
                .append("	default:")
                .append("\t\tlog.DefaultLogger.Errorf(\"[protocol][bolt] encode with unknown command : %+v\", model)")
                .append("		return nil, api.ErrUnknownType")
                .append("	}")
                .append("}")
                .line()
                .append("func (proto BoltProtocol) Decode(ctx context.Context, data api.IoBuffer) (interface{}, error) {")
                .append("	if data.Len() >= LessLen {")
                .append("		cmdType := data.Bytes()[1]")
                .line()
                .append("		switch cmdType {")
                .append("		case CmdTypeRequest:")
                .append("			return decodeRequest(ctx, data, false)")
                .append("		case CmdTypeRequestOneway:")
                .append("			return decodeRequest(ctx, data, true)")
                .append("		case CmdTypeResponse:")
                .append("			return decodeResponse(ctx, data)")
                .append("		default:")
                .append("			// unknown cmd type")
                .append("\t\t\treturn nil, fmt.Errorf(\"Decode Error, type = %s, value = %d\", UnKnownCmdType, cmdType)")
                .append("		}")
                .append("	}")
                .line()
                .append("	return nil, nil")
                .append("}");

        buffer.line()
                .append("func (proto BoltProtocol) Trigger(ctx context.Context, requestId uint64) api.XFrame {")
                .append("	return &Request{")
                .append("		RequestHeader: RequestHeader{")
                .append("			Protocol:  ProtocolCode,")
                .append("			CmdType:   CmdTypeRequest,")
                .append("			CmdCode:   CmdCodeHeartbeat,")
                .append("			Version:   1,")
                .append("			RequestId: uint32(requestId),")
                .append("			Codec:     Hessian2Serialize,")
                .append("			Timeout:   -1,")
                .append("		},")
                .append("	}")
                .append("}")
                .line()
                .append("func (proto BoltProtocol) Reply(ctx context.Context, request api.XFrame) api.XRespFrame {")
                .append("	return &Response{")
                .append("		ResponseHeader: ResponseHeader{")
                .append("			Protocol:       ProtocolCode,")
                .append("			CmdType:        CmdTypeResponse,")
                .append("			CmdCode:        CmdCodeHeartbeat,")
                .append("			Version:        ProtocolVersion,")
                .append("			RequestId:      uint32(request.GetRequestId()),")
                .append("			Codec:          Hessian2Serialize,")
                .append("			ResponseStatus: ResponseStatusSuccess,")
                .append("		},")
                .append("	}")
                .append("}")
                .line()
                .append("// Hijacker")
                .append("func (proto BoltProtocol) Hijack(ctx context.Context, request api.XFrame, statusCode uint32) api.XRespFrame {")
                .append("	return &Response{")
                .append("		ResponseHeader: ResponseHeader{")
                .append("			Protocol:       ProtocolCode,")
                .append("			CmdType:        CmdTypeResponse,")
                .append("			CmdCode:        CmdCodeRpcResponse,")
                .append("			Version:        ProtocolVersion,")
                .append("			RequestId:      0,                 // this would be overwrite by stream layer")
                .append("			Codec:          Hessian2Serialize,")
                .append("			ResponseStatus: uint16(statusCode),")
                .append("		},")
                .append("	}")
                .append("}")
                .line()
                .append("func (proto BoltProtocol) Mapping(httpStatusCode uint32) uint32 {")
                .append("	switch httpStatusCode {")
                .append("	case http.StatusOK:")
                .append("		return uint32(ResponseStatusSuccess)")
                .append("	case api.RouterUnavailableCode:")
                .append("		return uint32(ResponseStatusNoProcessor)")
                .append("	case api.NoHealthUpstreamCode:")
                .append("		return uint32(ResponseStatusConnectionClosed)")
                .append("	case api.UpstreamOverFlowCode:")
                .append("		return uint32(ResponseStatusServerThreadpoolBusy)")
                .append("	case api.CodecExceptionCode:")
                .append("		//Decode or Encode Error")
                .append("		return uint32(ResponseStatusCodecException)")
                .append("	case api.DeserialExceptionCode:")
                .append("		//Hessian Exception")
                .append("		return uint32(ResponseStatusServerDeserialException)")
                .append("	case api.TimeoutExceptionCode:")
                .append("		//Response Timeout")
                .append("		return uint32(ResponseStatusTimeout)")
                .append("	case api.PermissionDeniedCode:")
                .append("		//Response Permission Denied")
                .append("		// bolt protocol do not have a permission deny code, use server exception")
                .append("		return uint32(ResponseStatusServerException)")
                .append("	default:")
                .append("		return uint32(ResponseStatusUnknown)")
                .append("	}")
                .append("}")
                .line()
                .append("// PoolMode returns whether pingpong or multiplex")
                .append("func (proto BoltProtocol) PoolMode() api.PoolMode {")
                .append("	return api.Multiplex")
                .append("}")
                .line()
                .append("func (proto BoltProtocol) EnableWorkerPool() bool {")
                .append("	return true")
                .append("}")
                .line()
                .append("func (proto BoltProtocol) GenerateRequestID(streamID *uint64) uint64 {")
                .append("	return atomic.AddUint64(streamID, 1)")
                .append("}");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public Source types(ProtocolOption option) {
        String name = "types.go";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package bolt")
                .line()
                .append("import (")
                .append("\t\"errors\"")
                .append("\t\"time\"")
                .line()
                .append("\t\"mosn.io/api\"")
                .append(")")
                .line()
                .append("// bolt constants")
                .append("const (")
                .append("\tProtocolName    api.ProtocolName = \"bolt\" // protocol")
                .append("	ProtocolCode    byte             = 1")
                .append("	ProtocolVersion byte             = 1")
                .line()
                .append("	CmdTypeResponse      byte = 0 // cmd type")
                .append("	CmdTypeRequest       byte = 1")
                .append("	CmdTypeRequestOneway byte = 2")
                .line()
                .append("	CmdCodeHeartbeat   uint16 = 0 // cmd code")
                .append("	CmdCodeRpcRequest  uint16 = 1")
                .append("	CmdCodeRpcResponse uint16 = 2")
                .line()
                .append("	Hessian2Serialize byte = 1  // serialize")
                .append("	JsonSerialize     byte = 12 // json")
                .line()
                .append("	ResponseStatusSuccess                 uint16 = 0  // 0x00 response status")
                .append("	ResponseStatusError                   uint16 = 1  // 0x01")
                .append("	ResponseStatusServerException         uint16 = 2  // 0x02")
                .append("	ResponseStatusUnknown                 uint16 = 3  // 0x03")
                .append("	ResponseStatusServerThreadpoolBusy    uint16 = 4  // 0x04")
                .append("	ResponseStatusErrorComm               uint16 = 5  // 0x05")
                .append("	ResponseStatusNoProcessor             uint16 = 6  // 0x06")
                .append("	ResponseStatusTimeout                 uint16 = 7  // 0x07")
                .append("	ResponseStatusClientSendError         uint16 = 8  // 0x08")
                .append("	ResponseStatusCodecException          uint16 = 9  // 0x09")
                .append("	ResponseStatusConnectionClosed        uint16 = 16 // 0x10")
                .append("	ResponseStatusServerSerialException   uint16 = 17 // 0x11")
                .append("	ResponseStatusServerDeserialException uint16 = 18 // 0x12")
                .line()
                .append("	RequestHeaderLen  int = 22 // protocol header fields length")
                .append("	ResponseHeaderLen int = 20")
                .append("	LessLen           int = ResponseHeaderLen // minimal length for decoding")
                .line()
                .append("	RequestIdIndex         = 5")
                .append("	RequestHeaderLenIndex  = 16")
                .append("	ResponseHeaderLenIndex = 14")
                .append(")")
                .line()
                .append("const (")
                .append("	// Encode/Decode Exception Msg")
                .append("	UnKnownCmdType string = \"unknown cmd type\"")
                .append("	UnKnownCmdCode string = \"unknown cmd code\"")
                .line()
                .append("	// Sofa Rpc Default HC Parameters")
                .append("	SofaRPC                             = \"SofaRpc\"")
                .append("	DefaultBoltHeartBeatTimeout         = 6 * 15 * time.Second")
                .append("	DefaultBoltHeartBeatInterval        = 15 * time.Second")
                .append("	DefaultIntervalJitter               = 5 * time.Millisecond")
                .append("	DefaultHealthyThreshold      uint32 = 2")
                .append("	DefaultUnhealthyThreshold    uint32 = 2")
                .append(")")
                .line()
                .append("var (")
                .append("	// Encode/Decode Exception")
                .append("	ErrUnKnownCmdType = errors.New(UnKnownCmdType)")
                .append("	ErrUnKnownCmdCode = errors.New(UnKnownCmdCode)")
                .append(")");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public Source buffer(ProtocolOption option) {
        return null;
    }

    @Override
    public Source codec(ProtocolOption option) {
        String name = "codec.go";
        String path = "plugins/codecs/bolt/main";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());

        appendLicense(buffer);

        buffer.append("package main")
                .line()
                .append("import (")
                .append("\t\"context\"")
                .line()
                .with("\t\"").with(option.context().getModule()).append("/pkg/protocol/bolt\"")
                .line()
                .append("\t\"mosn.io/api\"")
                .append(")")
                .line()
                .append("// LoadCodec load codec function")
                .append("func LoadCodec() api.XProtocolCodec {")
                .append("	return &Codec{}")
                .append("}")
                .line()
                .append("type Codec struct {")
                .append("	mapping bolt.StatusMapping")
                .append("}")
                .line()
                .append("func (r Codec) ProtocolName() api.ProtocolName {")
                .append("	return bolt.ProtocolName")
                .append("}")
                .line()
                .append("func (r Codec) NewXProtocol(context.Context) api.XProtocol {")
                .append("	return &bolt.BoltProtocol{}")
                .append("}")
                .line()
                .append("func (r Codec) ProtocolMatch() api.ProtocolMatch {")
                .append("	return bolt.Matcher")
                .append("}")
                .line()
                .append("func (r Codec) HTTPMapping() api.HTTPMapping {")
                .append("	return r.mapping")
                .append("}")
                .line()
                .append("// compiler check")
                .append("var _ api.XProtocolCodec = &Codec{}");

        return new Source(name, path, buffer.toString());
    }

    @Override
    public List<Configuration> configurations(ProtocolOption option) {

        String path = "configs/codecs/bolt";

        List<Configuration> configurations = new ArrayList<>();

        // append egress_bolt.json
        configurations.add(
                new Configuration("egress_bolt.json", path,
                        new CodeBuilder(new StringBuilder())
                                .append("{")
                                .append("  \"name\": \"egress_sofa_bolt\",")
                                .append("  \"type\": \"egress\",")
                                .append("  \"address\": \"0.0.0.0:12220\",")
                                .append("  \"bind_port\": true,")
                                .append("  \"use_original_dst\": \"redirect\",")
                                .append("  \"filter_chains\": [")
                                .append("    {")
                                .append("      \"filters\": [")
                                .append("        {")
                                .append("          \"type\": \"tcpcopy\",")
                                .append("          \"config\": {")
                                .append("            \"port\": \"12220\"")
                                .append("          }")
                                .append("        },")
                                .append("        {")
                                .append("          \"type\": \"proxy\",")
                                .append("          \"config\": {")
                                .append("            \"name\": \"proxy_config\",")
                                .append("            \"downstream_protocol\": \"X\",")
                                .append("            \"upstream_protocol\": \"X\",")
                                .append("            \"extend_config\": {")
                                .append("              \"sub_protocol\": \"bolt\"")
                                .append("            },")
                                .append("            \"router_config_name\": \"sofa_egress_bolt_router\"")
                                .append("          }")
                                .append("        },")
                                .append("        {")
                                .append("          \"type\": \"connection_manager\",")
                                .append("          \"config\": {")
                                .append("            \"router_config_name\": \"sofa_egress_bolt_router\",")
                                .append("            \"router_configs\": \"./mosn/conf/routers/sofa_egress_bolt_router/\"")
                                .append("          }")
                                .append("        }")
                                .append("      ]")
                                .append("    }")
                                .append("  ],")
                                .append("  \"stream_filters\": [")
                                .append("    {")
                                .append("      \"type\": \"govern_config\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"transcoder\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"tamperproofing\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"rpc_service_tracer\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"cloud_metrics\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"fault_inject\",")
                                .append("      \"config\": {")
                                .append("        \"direction\": \"outbound\"")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"downgrade\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"alipayLimitFilter\",")
                                .append("      \"config\": {")
                                .append("        \"enable\": true,")
                                .append("        \"direction\": \"outbound\"")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"identity-provider\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"fault_tolerance_send\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"fault_tolerance_choose\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"alipayResourceAopFilter\",")
                                .append("      \"config\": {")
                                .append("        \"direction\": \"outbound\"")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"egress_shm_check\"")
                                .append("    }")
                                .append("  ]")
                                .append("}").toString()
                )
        );

        // append ingress_bolt.json.json
        configurations.add(
                new Configuration("ingress_bolt.json", path,
                        new CodeBuilder(new StringBuilder())
                                .append("{")
                                .append("  \"name\": \"ingress_sofa_bolt\",")
                                .append("  \"type\": \"ingress\",")
                                .append("  \"address\": \"0.0.0.0:12200\",")
                                .append("  \"bind_port\": true,")
                                .append("  \"use_original_dst\": \"redirect\",")
                                .append("  \"filter_chains\": [")
                                .append("    {")
                                .append("      \"filters\": [")
                                .append("        {")
                                .append("          \"type\": \"tcpcopy\",")
                                .append("          \"config\": {")
                                .append("            \"port\": \"12200\"")
                                .append("          }")
                                .append("        },")
                                .append("        {")
                                .append("          \"type\": \"proxy\",")
                                .append("          \"config\": {")
                                .append("            \"name\": \"proxy_config\",")
                                .append("            \"downstream_protocol\": \"X\",")
                                .append("            \"upstream_protocol\": \"X\",")
                                .append("            \"extend_config\": {")
                                .append("              \"sub_protocol\": \"bolt\"")
                                .append("            },")
                                .append("            \"router_config_name\": \"sofa_ingress_bolt_router\"")
                                .append("          }")
                                .append("        },")
                                .append("        {")
                                .append("          \"type\": \"connection_manager\",")
                                .append("          \"config\": {")
                                .append("            \"router_config_name\": \"sofa_ingress_bolt_router\",")
                                .append("            \"router_configs\": \"./mosn/conf/routers/sofa_ingress_bolt_router/\"")
                                .append("          }")
                                .append("        }")
                                .append("      ]")
                                .append("    }")
                                .append("  ],")
                                .append("  \"stream_filters\": [")
                                .append("    {")
                                .append("      \"type\": \"govern_config\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"transcoder\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"tamperproofing\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"rpc_service_tracer\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"cloud_metrics\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"fault_inject\",")
                                .append("      \"config\": {")
                                .append("        \"direction\": \"inbound\"")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"tls_trace\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"alipayDecodeFilter\",")
                                .append("      \"config\": {")
                                .append("        \"enable\": true,")
                                .append("        \"direction\": \"inbound\"")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"alipayLimitFilter\",")
                                .append("      \"config\": {")
                                .append("        \"enable\": true,")
                                .append("        \"direction\": \"inbound\"")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"fault_tolerance_send\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"fault_tolerance_choose\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"verify-identity\",")
                                .append("      \"config\": {")
                                .append("        \"mist_port\": 12311,")
                                .append("        \"key_sync_interval\": 10")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"req_decision\"")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"awatch\",")
                                .append("      \"config\": {")
                                .append("        \"log_dir_path\": \"/home/admin/logs/awatch-go/\",")
                                .append("        \"disk_inject_path\": \"/home/admin/logs/.chaos/\"")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"alipayResourceAopFilter\",")
                                .append("      \"config\": {")
                                .append("        \"direction\": \"inbound\"")
                                .append("      }")
                                .append("    },")
                                .append("    {")
                                .append("      \"type\": \"ingress_shm_check\"")
                                .append("    }")
                                .append("  ]")
                                .append("}").toString()
                )
        );

        return configurations;
    }

    @Override
    public Metadata metadata(ProtocolOption option) {
        String name = "metadata.json";
        String path = "configs/codecs/bolt";

        CodeBuilder buffer = new CodeBuilder(new StringBuilder());
        buffer.append("{")
                .append("\t\"name\": \"bolt\",")
                .append("\t\"kind\": \"protocol\",")
                .append("\t\"framework\": \"X\",")
                .append("\t\"internal\": false,")
                .append("\t\"variables\": [{")
                .append("\t\t\t\"field\": \"x-mosn-data-id\",")
                .append("\t\t\t\"pattern\": [\"${service}@DEFAULT\"],")
                .append("\t\t\t\"required\": true")
                .append("\t\t},")
                .append("\t\t{")
                .append("\t\t\t\"field\": \"x-mosn-method\",")
                .append("\t\t\t\"pattern\": [\"${sofa_head_method_name}\", \"${MethodName}\"],")
                .append("\t\t\t\"required\": false")
                .append("\t\t},")
                .append("\t\t{")
                .append("\t\t\t\"field\": \"x-mosn-caller-app\",")
                .append("\t\t\t\"pattern\": [\"${rpc_trace_context.sofaCallerApp}\", \"${X-CALLER-APP}\", \"${app}\"],")
                .append("\t\t\t\"required\": false")
                .append("\t\t},")
                .append("\t\t{")
                .append("\t\t\t\"field\": \"x-mosn-target-app\",")
                .append("\t\t\t\"pattern\": [\"${sofa_head_target_app}\"],")
                .append("\t\t\t\"required\": false")
                .append("\t\t}")
                .append("\t],")
                .append("\t\"dependencies\": [{")
                .with("\t\t\"mosn_api\": \"").with(option.getApi()).append("\",")
                .with("\t\t\"mosn_pkg\": \"").with(option.getPkg()).append("\"")
                .append("\t}]")
                .append("}");

        return new Metadata(name, path, buffer.toString());
    }
}
